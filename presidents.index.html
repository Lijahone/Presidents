<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Presidents (Hotseat) — Single File</title>
  <style>
    :root { --bg:#0b1020; --panel:#111a33; --panel2:#0f1630; --text:#e7ecff; --muted:#aab4e6; --accent:#7aa2ff; --danger:#ff6b6b; --ok:#53d18a; }
    * { box-sizing: border-box; }
    body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; background: radial-gradient(1000px 600px at 20% 0%, #1a2a6c33, transparent), var(--bg); color:var(--text); }
    a { color: var(--accent); }
    .wrap { max-width: 1100px; margin: 0 auto; padding: 16px; }
    header { display:flex; align-items:center; justify-content:space-between; gap:12px; flex-wrap:wrap; }
    header h1 { font-size: 18px; margin:0; letter-spacing: .3px; }
    header .sub { color:var(--muted); font-size: 12px; }
    .grid { display:grid; grid-template-columns: 360px 1fr; gap: 12px; margin-top: 12px; }
    @media (max-width: 980px) { .grid { grid-template-columns: 1fr; } }

    .card { background: linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02)); border: 1px solid rgba(255,255,255,.08); border-radius: 12px; padding: 12px; }
    .card h2 { margin:0 0 8px; font-size: 14px; color: #dbe2ff; }
    .row { display:flex; gap: 8px; align-items:center; flex-wrap:wrap; }
    .col { display:flex; flex-direction:column; gap: 8px; }

    label { font-size: 12px; color: var(--muted); }
    input[type="text"], input[type="number"], select {
      width: 100%;
      padding: 10px 10px;
      background: rgba(0,0,0,.25);
      border: 1px solid rgba(255,255,255,.12);
      border-radius: 10px;
      color: var(--text);
      outline: none;
    }
    input[type="number"] { width: 100px; }

    .btn {
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(122,162,255,.14);
      color: var(--text);
      padding: 10px 12px;
      border-radius: 10px;
      cursor:pointer;
      font-weight: 600;
      letter-spacing: .2px;
      user-select:none;
    }
    .btn:hover { filter: brightness(1.05); }
    .btn:disabled { opacity:.45; cursor:not-allowed; }
    .btn.secondary { background: rgba(255,255,255,.06); }
    .btn.danger { background: rgba(255,107,107,.18); border-color: rgba(255,107,107,.35); }
    .btn.ok { background: rgba(83,209,138,.16); border-color: rgba(83,209,138,.35); }

    .pill { display:inline-flex; align-items:center; gap: 8px; padding: 7px 10px; border-radius: 999px; border: 1px solid rgba(255,255,255,.12); background: rgba(0,0,0,.18); font-size: 12px; color: var(--muted); }
    .pill strong { color: var(--text); font-weight: 700; }

    .toggle { display:flex; align-items:center; justify-content:space-between; gap: 12px; padding: 10px; border-radius: 10px; border: 1px solid rgba(255,255,255,.10); background: rgba(0,0,0,.18); }
    .toggle .t { display:flex; flex-direction:column; gap:2px; }
    .toggle .t b { font-size: 12px; color: var(--text); }
    .toggle .t span { font-size: 11px; color: var(--muted); }
    .toggle input { transform: scale(1.2); }

    .players { display:flex; flex-direction:column; gap:8px; }
    .playerLine { display:flex; align-items:center; justify-content:space-between; gap:8px; padding: 8px 10px; border-radius: 10px; border: 1px solid rgba(255,255,255,.10); background: rgba(0,0,0,.14); }
    .playerLine .left { display:flex; flex-direction:column; gap:2px; }
    .playerLine .name { font-weight: 700; font-size: 13px; }
    .playerLine .meta { font-size: 11px; color: var(--muted); }
    .playerLine.active { outline: 2px solid rgba(122,162,255,.55); background: rgba(122,162,255,.10); }
    .playerLine.out { opacity: .6; }
    .badge { font-size: 11px; padding: 2px 8px; border-radius: 999px; border: 1px solid rgba(255,255,255,.14); background: rgba(255,255,255,.06); color: var(--text); }
    .badge.gold { border-color: rgba(255,215,0,.35); background: rgba(255,215,0,.10); }
    .badge.red { border-color: rgba(255,107,107,.35); background: rgba(255,107,107,.10); }
    .badge.blue { border-color: rgba(122,162,255,.35); background: rgba(122,162,255,.12); }

    .tableTop { display:flex; gap:12px; align-items:flex-start; flex-wrap:wrap; }
    .pileBox { min-width: 220px; flex: 1; }
    .handBox { flex: 2; min-width: 280px; }
    .pile {
      display:flex; flex-direction:column; gap:8px;
      padding: 12px;
      border-radius: 12px;
      border: 1px dashed rgba(255,255,255,.16);
      background: rgba(0,0,0,.18);
    }
    .pile .big { font-size: 18px; font-weight: 800; letter-spacing:.3px; }
    .pile .small { font-size: 12px; color: var(--muted); }

    .hand {
      display:flex;
      flex-wrap:wrap;
      gap:8px;
      padding: 10px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.16);
      min-height: 84px;
    }
    .c {
      padding: 8px 10px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      cursor:pointer;
      user-select:none;
      font-weight: 800;
      letter-spacing:.2px;
      min-width: 48px;
      text-align:center;
    }
    .c.red { color: #ff9aa0; border-color: rgba(255,107,107,.25); }
    .c.sel { outline: 2px solid rgba(122,162,255,.65); background: rgba(122,162,255,.18); }
    .c.disabled { opacity: .45; cursor:not-allowed; }
    .hint { font-size: 12px; color: var(--muted); line-height: 1.35; }

    .actions { display:flex; gap:8px; flex-wrap:wrap; margin-top: 10px; }
    .log { max-height: 220px; overflow:auto; padding: 10px; border-radius: 12px; border: 1px solid rgba(255,255,255,.10); background: rgba(0,0,0,.16); }
    .log p { margin: 0 0 8px; font-size: 12px; color: var(--muted); }
    .log p b { color: var(--text); }

    .overlay {
      position: fixed; inset:0;
      display:none;
      align-items:center; justify-content:center;
      background: rgba(0,0,0,.70);
      z-index: 50;
      padding: 16px;
    }
    .overlay .modal {
      max-width: 520px; width: 100%;
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      border: 1px solid rgba(255,255,255,.12);
      border-radius: 16px;
      padding: 16px;
    }
    .modal h3 { margin: 0 0 8px; font-size: 16px; }
    .modal .big { font-size: 22px; font-weight: 900; margin: 8px 0; }
    .modal .muted { color: var(--muted); font-size: 12px; }
    .divider { height:1px; background: rgba(255,255,255,.10); margin: 10px 0; }

    .footerNote { font-size: 11px; color: var(--muted); margin-top: 8px; }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div>
        <h1>Presidents (Hotseat)</h1>
        <div class="sub">Single-file prototype • local pass-and-play • rule toggles included</div>
      </div>
      <div class="row">
        <span class="pill">Phase: <strong id="phasePill">Setup</strong></span>
        <button class="btn secondary" id="btnResetAll">Reset</button>
      </div>
    </header>

    <div class="grid">
      <div class="col">
        <div class="card" id="setupCard">
          <h2>Setup</h2>
          <div class="row" style="justify-content:space-between;">
            <div>
              <label>Players (3–8)</label><br/>
              <input type="number" id="playerCount" min="3" max="8" value="4" />
            </div>
            <div>
              <label>Preset</label><br/>
              <select id="preset">
                <option value="classic">Classic</option>
                <option value="fast">Fast (2 clears + 4 clears)</option>
                <option value="noswaps">No swaps</option>
              </select>
            </div>
          </div>

          <div style="margin-top:10px;">
            <label>Player names</label>
            <div class="players" id="playerInputs" style="margin-top:8px;"></div>
          </div>

          <div class="actions">
            <button class="btn ok" id="btnStart">Start Game</button>
          </div>

          <div class="footerNote">
            Tip: This is hotseat/local only. Later we’ll add online multiplayer (server + GitHub Pages).
          </div>
        </div>

        <div class="card" id="rulesCard">
          <h2>Rules (toggles)</h2>

          <div class="toggle">
            <div class="t">
              <b>2 clears the pile</b>
              <span>Playing a 2 bombs/clears and you lead again</span>
            </div>
            <input type="checkbox" id="r_twoClears" checked />
          </div>

          <div class="toggle">
            <div class="t">
              <b>4-of-a-kind clears (single play)</b>
              <span>Playing 4 of the same rank clears and you lead again</span>
            </div>
            <input type="checkbox" id="r_fourClears" />
          </div>

          <div class="toggle">
            <div class="t">
              <b>Must match set size</b>
              <span>If a pair is played, you must play a pair to beat it</span>
            </div>
            <input type="checkbox" id="r_matchSize" checked />
          </div>

          <div class="toggle">
            <div class="t">
              <b>Starting rule: lowest card starts</b>
              <span>First trick of round: player holding the lowest card leads</span>
            </div>
            <input type="checkbox" id="r_lowestStarts" checked />
          </div>

          <div class="toggle">
            <div class="t">
              <b>Swaps between rounds</b>
              <span>President↔Scum (2 cards), Vice↔Vice Scum (1 card)</span>
            </div>
            <input type="checkbox" id="r_swaps" checked />
          </div>

          <div class="row" style="margin-top:10px;">
            <span class="pill">Ranking: <strong>3 … A, 2 high</strong></span>
            <span class="pill">Suits: <strong>ignored</strong></span>
          </div>
        </div>

        <div class="card">
          <h2>Log</h2>
          <div class="log" id="log"></div>
        </div>
      </div>

      <div class="col">
        <div class="card">
          <h2>Table</h2>
          <div class="tableTop">
            <div class="pileBox">
              <div class="pile">
                <div class="big" id="pileTop">Pile: (empty)</div>
                <div class="small" id="pileReq">Required set size: —</div>
                <div class="small" id="pilePass">Passes: —</div>
              </div>
              <div class="actions" style="margin-top:10px;">
                <button class="btn secondary" id="btnReveal" disabled>Reveal Hand</button>
                <button class="btn secondary" id="btnEndTurn" disabled>End Turn / Pass Device</button>
              </div>
              <p class="hint" id="turnHint" style="margin-top:10px;"></p>
            </div>

            <div class="handBox">
              <div class="row" style="justify-content:space-between;">
                <span class="pill">Current: <strong id="currentName">—</strong></span>
                <span class="pill">Selected: <strong id="selInfo">0</strong></span>
              </div>

              <div class="divider"></div>

              <div class="hand" id="hand"></div>

              <div class="actions">
                <button class="btn ok" id="btnPlay" disabled>Play</button>
                <button class="btn" id="btnPass" disabled>Pass</button>
                <button class="btn secondary" id="btnClearSel" disabled>Clear Selection</button>
              </div>

              <div class="divider"></div>

              <div class="players" id="playersPanel"></div>

              <div class="actions" style="margin-top:10px;">
                <button class="btn secondary" id="btnNewRound" disabled>Next Round</button>
                <button class="btn danger" id="btnBackToSetup" disabled>Back to Setup</button>
              </div>

              <p class="hint" style="margin-top:10px;">
                Hotseat flow: tap <b>Reveal Hand</b> → play/pass → tap <b>End Turn</b> and hand device to next player.
              </p>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div class="overlay" id="overlay">
    <div class="modal">
      <h3 id="ovTitle">Pass the device</h3>
      <div class="big" id="ovBig">—</div>
      <div class="muted" id="ovMuted">—</div>
      <div class="divider"></div>
      <div class="actions">
        <button class="btn ok" id="ovOk">Continue</button>
      </div>
    </div>
  </div>

<script>
(() => {
  const $ = (id) => document.getElementById(id);

  const SUITS = ["C","D","H","S"];
  const SUIT_SYMBOL = { C:"♣", D:"♦", H:"♥", S:"♠" };
  const SUIT_COLOR_CLASS = { C:"", D:"red", H:"red", S:"" };

  const rankToLabel = (r) => {
    if (r <= 10) return String(r);
    if (r === 11) return "J";
    if (r === 12) return "Q";
    if (r === 13) return "K";
    if (r === 14) return "A";
    if (r === 15) return "2";
    return "?";
  };

  const cardToText = (c) => `${rankToLabel(c.rank)}${SUIT_SYMBOL[c.suit]}`;

  const sortHand = (hand) => {
    hand.sort((a,b) => (a.rank - b.rank) || (SUITS.indexOf(a.suit) - SUITS.indexOf(b.suit)));
  };

  const state = {
    phase: "setup",
    rules: {
      twoClearsPile: true,
      fourOfAKindClears: false,
      mustMatchSetSize: true,
      lowestCardStarts: true,
      swapsEnabled: true,
    },
    players: [],
    roundNumber: 1,
    turnIndex: 0,
    leaderIndex: 0,
    pileTop: null,
    requiredCount: null,
    passes: new Set(),
    lastNonPassIndex: null,
    handRevealed: false,
    selected: new Set(),
    finishOrder: [],
  };

  const phasePill = $("phasePill");
  const playerCount = $("playerCount");
  const playerInputs = $("playerInputs");
  const preset = $("preset");

  const r_twoClears = $("r_twoClears");
  const r_fourClears = $("r_fourClears");
  const r_matchSize = $("r_matchSize");
  const r_lowestStarts = $("r_lowestStarts");
  const r_swaps = $("r_swaps");

  const btnStart = $("btnStart");
  const btnResetAll = $("btnResetAll");

  const pileTopEl = $("pileTop");
  const pileReqEl = $("pileReq");
  const pilePassEl = $("pilePass");

  const btnReveal = $("btnReveal");
  const btnEndTurn = $("btnEndTurn");
  const btnPlay = $("btnPlay");
  const btnPass = $("btnPass");
  const btnClearSel = $("btnClearSel");

  const currentName = $("currentName");
  const selInfo = $("selInfo");
  const handEl = $("hand");
  const playersPanel = $("playersPanel");
  const turnHint = $("turnHint");
  const logEl = $("log");

  const btnNewRound = $("btnNewRound");
  const btnBackToSetup = $("btnBackToSetup");

  const overlay = $("overlay");
  const ovTitle = $("ovTitle");
  const ovBig = $("ovBig");
  const ovMuted = $("ovMuted");
  const ovOk = $("ovOk");

  function log(msg, strong=false) {
    const p = document.createElement("p");
    p.innerHTML = strong ? `<b>${msg}</b>` : msg;
    logEl.prepend(p);
  }

  function clampInt(v, min, max) {
    let x = parseInt(v, 10);
    if (Number.isNaN(x)) x = min;
    return Math.max(min, Math.min(max, x));
  }

  function defaultName(i) {
    const defs = ["Player 1","Player 2","Player 3","Player 4","Player 5","Player 6","Player 7","Player 8"];
    return defs[i] || `Player ${i+1}`;
  }

  function renderPlayerInputs() {
    const n = clampInt(playerCount.value, 3, 8);
    playerCount.value = n;
    playerInputs.innerHTML = "";
    for (let i=0; i<n; i++) {
      const inp = document.createElement("input");
      inp.type = "text";
      inp.placeholder = `Player ${i+1} name`;
      inp.value = defaultName(i);
      inp.id = `pname_${i}`;
      playerInputs.appendChild(inp);
    }
  }

  function applyPreset(name) {
    if (name === "classic") {
      r_twoClears.checked = true;
      r_fourClears.checked = false;
      r_matchSize.checked = true;
      r_lowestStarts.checked = true;
      r_swaps.checked = true;
    } else if (name === "fast") {
      r_twoClears.checked = true;
      r_fourClears.checked = true;
      r_matchSize.checked = true;
      r_lowestStarts.checked = true;
      r_swaps.checked = true;
    } else if (name === "noswaps") {
      r_twoClears.checked = true;
      r_fourClears.checked = false;
      r_matchSize.checked = true;
      r_lowestStarts.checked = true;
      r_swaps.checked = false;
    }
    syncRulesFromUI();
    render();
  }

  function syncRulesFromUI() {
    state.rules.twoClearsPile = !!r_twoClears.checked;
    state.rules.fourOfAKindClears = !!r_fourClears.checked;
    state.rules.mustMatchSetSize = !!r_matchSize.checked;
    state.rules.lowestCardStarts = !!r_lowestStarts.checked;
    state.rules.swapsEnabled = !!r_swaps.checked;
  }

  function makeDeck() {
    const deck = [];
    for (let rank = 3; rank <= 15; rank++) {
      for (const suit of SUITS) deck.push({ rank, suit });
    }
    for (let i = deck.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [deck[i], deck[j]] = [deck[j], deck[i]];
    }
    return deck;
  }

  function deal(deck, playerCount) {
    const hands = Array.from({length: playerCount}, () => []);
    let idx = 0;
    while (deck.length) {
      hands[idx % playerCount].push(deck.pop());
      idx++;
    }
    hands.forEach(sortHand);
    return hands;
  }

  function findLowestCardHolder() {
    let best = null;
    for (let pi=0; pi<state.players.length; pi++) {
      const hand = state.players[pi].hand;
      for (const c of hand) {
        if (!best) best = { pi, c };
        else {
          const a = c, b = best.c;
          const suitA = SUITS.indexOf(a.suit), suitB = SUITS.indexOf(b.suit);
          if (a.rank < b.rank || (a.rank === b.rank && suitA < suitB)) best = { pi, c };
        }
      }
    }
    return best ? best.pi : 0;
  }

  function activePlayerIndices() {
    const arr = [];
    for (let i=0;i<state.players.length;i++) if (!state.players[i].out) arr.push(i);
    return arr;
  }

  function nextActiveIndex(fromIndex) {
    const n = state.players.length;
    for (let step=1; step<=n; step++) {
      const idx = (fromIndex + step) % n;
      if (!state.players[idx].out) return idx;
    }
    return fromIndex;
  }

  function countActiveNotPassed() {
    const act = activePlayerIndices();
    let notPassed = 0;
    for (const i of act) if (!state.passes.has(i)) notPassed++;
    return notPassed;
  }

  function validateSelection(cards) {
    if (state.phase !== "in_round") return { ok:false, reason:"Game not in round." };
    if (!state.handRevealed) return { ok:false, reason:"Reveal your hand first." };
    if (state.players[state.turnIndex].out) return { ok:false, reason:"You are already out." };
    if (!cards.length) return { ok:false, reason:"Select at least 1 card." };

    const rank = cards[0].rank;
    for (const c of cards) if (c.rank !== rank) return { ok:false, reason:"All selected cards must be the same rank." };

    const count = cards.length;

    if (state.requiredCount !== null && state.rules.mustMatchSetSize) {
      if (count !== state.requiredCount) return { ok:false, reason:`Must play exactly ${state.requiredCount} card(s).` };
    }

    if (state.pileTop) {
      const topRank = state.pileTop.rank;
      const isTwoClear = state.rules.twoClearsPile && rank === 15;
      const isFourClear = state.rules.fourOfAKindClears && count === 4;

      if (!isTwoClear && !isFourClear) {
        if (rank <= topRank) return { ok:false, reason:`Must play a higher rank than ${rankToLabel(topRank)}.` };
      }
    }
    return { ok:true, reason:"OK" };
  }

  function clearPile(message) {
    if (message) log(message, true);
    state.pileTop = null;
    state.requiredCount = null;
    state.passes.clear();
    state.lastNonPassIndex = null;
  }

  function showOverlay(title, big, muted) {
    ovTitle.textContent = title;
    ovBig.textContent = big;
    ovMuted.textContent = muted || "";
    overlay.style.display = "flex";
  }
  function hideOverlay() { overlay.style.display = "none"; }

  function applyPlay(cards) {
    const pi = state.turnIndex;
    const player = state.players[pi];

    const set = new Set(cards.map(c => c.rank + "_" + c.suit));
    player.hand = player.hand.filter(c => !set.has(c.rank + "_" + c.suit));

    state.pileTop = {
      rank: cards[0].rank,
      count: cards.length,
      playerIndex: pi,
      cardsText: cards.map(cardToText).join(" "),
    };
    state.requiredCount = state.rules.mustMatchSetSize ? cards.length : null;
    state.lastNonPassIndex = pi;
    state.passes.clear();

    log(`${player.name} played ${state.pileTop.cardsText} (${rankToLabel(state.pileTop.rank)} x${state.pileTop.count}).`);

    if (player.hand.length === 0 && !player.out) {
      player.out = true;
      player.finishIndex = state.finishOrder.length;
      state.finishOrder.push(pi);
      log(`${player.name} is OUT!`, true);
    }

    const isTwoClear = state.rules.twoClearsPile && cards[0].rank === 15;
    const isFourClear = state.rules.fourOfAKindClears && cards.length === 4;

    if (isTwoClear || isFourClear) {
      clearPile(`${player.name} cleared the pile!`);
      state.handRevealed = false;
      state.selected.clear();
      showOverlay("Pile Cleared", `Pass device to ${player.name}`, "They lead again. Tap Continue when ready.");
      return;
    }

    state.turnIndex = nextActiveIndex(state.turnIndex);
    state.handRevealed = false;
    state.selected.clear();

    showOverlay("Next Turn", `Pass device to ${state.players[state.turnIndex].name}`, "Tap Continue when ready.");
  }

  function applyPass() {
    const pi = state.turnIndex;
    const player = state.players[pi];

    log(`${player.name} passed.`);
    state.passes.add(pi);

    if (state.pileTop && countActiveNotPassed() <= 1) {
      const winner = state.lastNonPassIndex;
      const winnerName = (winner !== null) ? state.players[winner].name : "—";
      clearPile(`${winnerName} wins the trick and leads.`);
      if (winner !== null) state.turnIndex = winner;

      state.handRevealed = false;
      state.selected.clear();

      showOverlay("Trick Won", `Pass device to ${state.players[state.turnIndex].name}`, "They lead the next trick. Tap Continue.");
      return;
    }

    state.turnIndex = nextActiveIndex(state.turnIndex);
    state.handRevealed = false;
    state.selected.clear();

    showOverlay("Next Turn", `Pass device to ${state.players[state.turnIndex].name}`, "Tap Continue when ready.");
  }

  function isRoundOver() {
    const active = activePlayerIndices();
    return active.length <= 1;
  }

  function finishLabel(pos, n) {
    if (pos === 0) return "President";
    if (pos === 1) return "Vice President";
    if (pos === n-2) return "Vice Scum";
    if (pos === n-1) return "Scum";
    return `Middle (${pos+1})`;
  }

  function performSwap(aIndex, bIndex, count) {
    const A = state.players[aIndex];
    const B = state.players[bIndex];
    if (!A || !B) return;

    sortHand(A.hand);
    sortHand(B.hand);

    const giveA = A.hand.slice(0, count);
    const giveB = B.hand.slice(Math.max(0, B.hand.length - count));

    const setA = new Set(giveA.map(c => c.rank+"_"+c.suit));
    const setB = new Set(giveB.map(c => c.rank+"_"+c.suit));
    A.hand = A.hand.filter(c => !setA.has(c.rank+"_"+c.suit));
    B.hand = B.hand.filter(c => !setB.has(c.rank+"_"+c.suit));

    A.hand.push(...giveB);
    B.hand.push(...giveA);

    sortHand(A.hand);
    sortHand(B.hand);

    log(`${A.name} swapped ${count} card(s) with ${B.name}.`);
  }

  function finalizeRound() {
    const remaining = activePlayerIndices();
    if (remaining.length === 1) {
      const last = remaining[0];
      if (!state.players[last].out) {
        state.players[last].out = true;
        state.players[last].finishIndex = state.finishOrder.length;
        state.finishOrder.push(last);
      }
    }

    state.phase = "between_rounds";
    phasePill.textContent = "Between rounds";

    const n = state.players.length;
    log(`Round ${state.roundNumber} results:`, true);
    for (let i=0;i<state.finishOrder.length;i++) {
      const pi = state.finishOrder[i];
      log(`${i+1}. ${state.players[pi].name} — ${finishLabel(i, n)}`);
    }

    if (state.rules.swapsEnabled && n >= 4) {
      const pres = state.finishOrder[0];
      const scum = state.finishOrder[n-1];
      const vp = state.finishOrder[1];
      const vsc = state.finishOrder[n-2];

      performSwap(pres, scum, 2);
      performSwap(vp, vsc, 1);

      log(`Swaps applied for next round.`, true);
    }

    clearPile(null);
    btnNewRound.disabled = false;
    btnBackToSetup.disabled = false;

    showOverlay(
      `Round ${state.roundNumber} Complete`,
      `${state.players[state.finishOrder[0]].name} is President`,
      `Tap Continue to start the next round when ready.`
    );
  }

  function startRound() {
    state.phase = "in_round";
    phasePill.textContent = "In round";
    state.pileTop = null;
    state.requiredCount = null;
    state.passes = new Set();
    state.lastNonPassIndex = null;
    state.finishOrder = [];
    state.selected.clear();
    state.handRevealed = false;

    for (const p of state.players) {
      p.out = false;
      p.finishIndex = null;
      sortHand(p.hand);
    }

    if (state.rules.lowestCardStarts) {
      state.turnIndex = findLowestCardHolder();
      state.leaderIndex = state.turnIndex;
      log(`Lowest card starts: ${state.players[state.turnIndex].name} leads Round ${state.roundNumber}.`, true);
    } else {
      state.turnIndex = state.leaderIndex || 0;
      log(`${state.players[state.turnIndex].name} leads Round ${state.roundNumber}.`, true);
    }

    btnNewRound.disabled = true;
    btnBackToSetup.disabled = true;

    showOverlay("Round Start", `Pass device to ${state.players[state.turnIndex].name}`, "Tap Continue when ready.");
  }

  function startGameFromSetup() {
    syncRulesFromUI();
    const n = clampInt(playerCount.value, 3, 8);
    const names = [];
    for (let i=0;i<n;i++) {
      const val = ($(`pname_${i}`)?.value || defaultName(i)).trim();
      names.push(val || defaultName(i));
    }

    state.players = names.map(name => ({ name, hand: [], out:false, finishIndex:null }));
    state.roundNumber = 1;
    state.leaderIndex = 0;

    const deck = makeDeck();
    const hands = deal(deck, n);
    for (let i=0;i<n;i++) state.players[i].hand = hands[i];

    log(`Game started with ${n} players.`, true);
    startRound();
    render();
  }

  function nextRound() {
    state.roundNumber++;
    const pres = state.finishOrder[0];
    state.leaderIndex = (pres !== undefined) ? pres : 0;
    startRound();
    render();
  }

  function renderPile() {
    pileTopEl.textContent = state.pileTop ? `Pile: ${rankToLabel(state.pileTop.rank)} × ${state.pileTop.count}` : "Pile: (empty)";
    pileReqEl.textContent = `Required set size: ${state.requiredCount === null ? "—" : state.requiredCount}`;
    pilePassEl.textContent = `Passes: ${
      state.passes.size ? [...state.passes].map(i => state.players[i].name).join(", ") : "—"
    }`;
  }

  function renderPlayersPanel() {
    playersPanel.innerHTML = "";
    const n = state.players.length;
    for (let i=0;i<n;i++) {
      const p = state.players[i];
      const line = document.createElement("div");
      line.className = "playerLine" + (i===state.turnIndex && state.phase==="in_round" ? " active" : "") + (p.out ? " out" : "");
      const left = document.createElement("div");
      left.className = "left";
      const name = document.createElement("div");
      name.className = "name";
      name.textContent = p.name;
      const meta = document.createElement("div");
      meta.className = "meta";
      const finish = (p.finishIndex !== null) ? finishLabel(p.finishIndex, n) : "";
      meta.textContent = `Cards: ${p.hand.length}` + (finish ? ` • ${finish}` : "");

      left.appendChild(name);
      left.appendChild(meta);

      const right = document.createElement("div");
      const badge = document.createElement("span");
      badge.className = "badge";
      if (p.finishIndex === 0) badge.className += " gold";
      if (p.finishIndex === n-1) badge.className += " red";
      if (i === state.turnIndex && state.phase==="in_round") badge.className += " blue";
      badge.textContent = p.out ? (finish || "Out") : (i===state.turnIndex && state.phase==="in_round" ? "Turn" : "Playing");
      right.appendChild(badge);

      line.appendChild(left);
      line.appendChild(right);
      playersPanel.appendChild(line);
    }
  }

  function renderHand() {
    handEl.innerHTML = "";
    state.selected.clear();
    selInfo.textContent = "0";
    const p = state.players[state.turnIndex];
    currentName.textContent = p ? p.name : "—";

    if (state.phase !== "in_round") {
      handEl.innerHTML = `<div class="hint">Start a round to view hands.</div>`;
      return;
    }

    if (!state.handRevealed) {
      handEl.innerHTML = `<div class="hint">Hand hidden. Tap <b>Reveal Hand</b>.</div>`;
      return;
    }

    sortHand(p.hand);

    p.hand.forEach((c, idx) => {
      const btn = document.createElement("div");
      btn.className = "c " + SUIT_COLOR_CLASS[c.suit];
      btn.textContent = `${rankToLabel(c.rank)}${SUIT_SYMBOL[c.suit]}`;

      btn.addEventListener("click", () => {
        if (!state.handRevealed) return;

        if (state.selected.has(idx)) state.selected.delete(idx);
        else state.selected.add(idx);

        updateSelectionUI();
        renderHandSelectionOnly();
      });

      handEl.appendChild(btn);
    });

    renderHandSelectionOnly();
    updateSelectionUI();
  }

  function renderHandSelectionOnly() {
    const children = [...handEl.children];
    children.forEach((node, idx) => {
      if (!(node instanceof HTMLElement)) return;
      node.classList.toggle("sel", state.selected.has(idx));
    });
  }

  function updateSelectionUI() {
    const p = state.players[state.turnIndex];
    const idxs = [...state.selected].sort((a,b)=>a-b);
    const cards = idxs.map(i => p.hand[i]).filter(Boolean);
    selInfo.textContent = String(cards.length);

    btnClearSel.disabled = cards.length === 0;

    const inTurn = state.phase === "in_round" && state.handRevealed && !p.out;
    btnPass.disabled = !inTurn;
    btnPlay.disabled = !(inTurn && cards.length > 0);
  }

  function renderTurnHint() {
    if (state.phase === "setup") {
      turnHint.textContent = "Set players and rules, then start.";
      return;
    }
    if (state.phase === "between_rounds") {
      turnHint.textContent = `Round ${state.roundNumber} complete. Start next round when ready.`;
      return;
    }
    const p = state.players[state.turnIndex];
    const req = state.requiredCount;
    const top = state.pileTop ? `${rankToLabel(state.pileTop.rank)} × ${state.pileTop.count}` : "empty";
    let extra = "";
    if (req !== null && state.rules.mustMatchSetSize) extra = ` You must play exactly ${req} card(s).`;
    turnHint.textContent = `${p.name}'s turn. Pile is ${top}.${extra}`;
  }

  function renderButtons() {
    const inRound = state.phase === "in_round";
    btnReveal.disabled = !inRound;
    btnEndTurn.disabled = !inRound;
    btnReveal.textContent = state.handRevealed ? "Hide Hand" : "Reveal Hand";

    btnNewRound.disabled = state.phase !== "between_rounds";
    btnBackToSetup.disabled = state.phase === "in_round";
  }

  function render() {
    phasePill.textContent =
      state.phase === "setup" ? "Setup" :
      state.phase === "in_round" ? "In round" : "Between rounds";

    renderPile();
    renderPlayersPanel();
    renderHand();
    renderTurnHint();
    renderButtons();
  }

  playerCount.addEventListener("change", renderPlayerInputs);
  preset.addEventListener("change", () => applyPreset(preset.value));
  [r_twoClears, r_fourClears, r_matchSize, r_lowestStarts, r_swaps].forEach(el => {
    el.addEventListener("change", () => { syncRulesFromUI(); render(); });
  });

  btnStart.addEventListener("click", () => {
    if (state.phase !== "setup") return;
    startGameFromSetup();
  });

  btnResetAll.addEventListener("click", () => {
    if (!confirm("Reset everything?")) return;
    resetAll();
  });

  btnBackToSetup.addEventListener("click", () => {
    if (state.phase === "in_round") return;
    if (!confirm("Go back to setup? This will reset the current game.")) return;
    resetAll();
  });

  btnNewRound.addEventListener("click", () => {
    if (state.phase !== "between_rounds") return;
    nextRound();
  });

  btnReveal.addEventListener("click", () => {
    if (state.phase !== "in_round") return;
    state.handRevealed = !state.handRevealed;
    state.selected.clear();
    render();
  });

  btnEndTurn.addEventListener("click", () => {
    if (state.phase !== "in_round") return;
    state.handRevealed = false;
    state.selected.clear();
    showOverlay("Pass the Device", `Next: ${state.players[state.turnIndex].name}`, "Tap Continue when ready.");
    render();
  });

  btnClearSel.addEventListener("click", () => {
    state.selected.clear();
    updateSelectionUI();
    renderHandSelectionOnly();
    renderButtons();
  });

  btnPlay.addEventListener("click", () => {
    if (state.phase !== "in_round") return;
    const p = state.players[state.turnIndex];
    const idxs = [...state.selected].sort((a,b)=>a-b);
    const cards = idxs.map(i => p.hand[i]).filter(Boolean);
    const v = validateSelection(cards);
    if (!v.ok) {
      alert(v.reason);
      return;
    }

    applyPlay(cards);
    if (isRoundOver()) finalizeRound();
    render();
  });

  btnPass.addEventListener("click", () => {
    if (state.phase !== "in_round") return;
    applyPass();
    if (isRoundOver()) finalizeRound();
    render();
  });

  ovOk.addEventListener("click", () => {
    hideOverlay();
    render();
  });

  function resetAll() {
    state.phase = "setup";
    state.players = [];
    state.roundNumber = 1;
    state.turnIndex = 0;
    state.leaderIndex = 0;
    state.pileTop = null;
    state.requiredCount = null;
    state.passes = new Set();
    state.lastNonPassIndex = null;
    state.handRevealed = false;
    state.selected = new Set();
    state.finishOrder = [];
    logEl.innerHTML = "";
    log("Reset.", true);
    renderPlayerInputs();
    applyPreset(preset.value);
    render();
  }

  renderPlayerInputs();
  applyPreset("classic");
  resetAll();
})();
</script>
</body>
</html>
